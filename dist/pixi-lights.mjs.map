{"version":3,"file":"pixi-lights.mjs","sources":["../src/mixins/Circle.ts","../src/LayerFinder.ts","../src/lights/light/ViewportQuad.ts","../src/lights/light/Light.ts","../src/lights/shared.ts","../src/lights/light/LightShader.ts","../src/lights/ambientLight/ambient.frag.ts","../src/lights/ambientLight/AmbientLightShader.ts","../src/lights/ambientLight/AmbientLight.ts","../src/lights/pointLight/point.frag.ts","../src/lights/pointLight/PointLightShader.ts","../src/lights/pointLight/PointLight.ts","../src/lights/directionalLight/directional.frag.ts","../src/lights/directionalLight/DirectionalLightShader.ts","../src/lights/directionalLight/DirectionalLight.ts"],"sourcesContent":["import { Circle } from '@pixi/core';\n\n/**\n * PixiJS namespace.\n * @namespace PIXI\n */\n\n/**\n * PixiJS Lights namespace.\n * @namespace PIXI.lights\n */\n\n/**\n * Circle class from PixiJS.\n * @class PIXI.Circle\n */\n\n/**\n * Creates vertices and indices arrays to describe this circle.\n * @method PIXI.Circle#getMesh\n * @param {PIXI.Circle} shape -\n * @param {number} [totalSegments=40] - Total segments to build for the circle mesh.\n * @param vertices -\n * @param indices -\n *  `((totalSegments + 2) * 2)` or more. If not passed it is created for you.\n *  be `(totalSegments + 3)` or more. If not passed it is created for you.\n * @return {PIXI.lights.CircleMeshData} Object with verticies and indices arrays\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getCircleMesh(shape: Circle, totalSegments = 40, vertices?: Float32Array, indices?: Uint16Array)\n{\n    vertices = vertices || new Float32Array((totalSegments + 1) * 2);\n    indices = indices || new Uint16Array(totalSegments + 1);\n\n    const seg = (Math.PI * 2) / totalSegments;\n    let indicesIndex = -1;\n\n    indices[++indicesIndex] = indicesIndex;\n\n    for (let i = 0; i <= totalSegments; ++i)\n    {\n        const index = i * 2;\n        const angle = seg * i;\n\n        vertices[index] = Math.cos(angle) * shape.radius;\n        vertices[index + 1] = Math.sin(angle) * shape.radius;\n\n        indices[++indicesIndex] = indicesIndex;\n    }\n\n    indices[indicesIndex] = 1;\n\n    return { vertices, indices };\n}\n\n/**\n * @memberof PIXI.lights\n * @property {Float32Array} vertices - Vertices data\n * @property {Uint16Array} indices - Indices data\n */\nexport interface CircleMeshData\n{\n    vertices: Float32Array;\n    indices: Uint16Array;\n}\n","import { Texture } from '@pixi/core';\nimport { Group, Layer } from '@pixi/layers';\n\n/**\n * @memberof PIXI.lights\n * @static\n * @type {PIXI.layers.Group}\n */\nexport const diffuseGroup = new Group(0, false);\n\n/**\n * @memberof PIXI.lights\n * @static\n * @type {PIXI.layers.Group}\n */\nexport const normalGroup = new Group(0, false);\n\n/**\n * @memberof PIXI.lights\n * @static\n * @type {PIXI.layers.Group}\n */\nexport const lightGroup = new Group(0, false);\n\ndiffuseGroup.useRenderTexture = true;\nnormalGroup.useRenderTexture = true;\n\n/**\n * @memberof PIXI.lights\n */\nexport class LayerFinder\n{\n    /**\n     * Last layer\n     * @type {PIXI.layers.Layer}\n     */\n    lastLayer: Layer | null = null;\n    /**\n     * Diffuse texture\n     * @type {PIXI.Texture}\n     */\n    diffuseTexture: Texture | null = null;\n    /**\n     * Normal texture\n     * @type {PIXI.Texture}\n     */\n    normalTexture: Texture | null = null;\n\n    /**\n     * Check\n     * @param {PIXI.layers.Layer} layer -\n     */\n    check(layer: Layer): void\n    {\n        if (this.lastLayer === layer)\n        {\n            return;\n        }\n        this.lastLayer = layer;\n\n        const stage = layer._activeStageParent;\n        const layerAny = layer as any;\n\n        this.diffuseTexture = Texture.WHITE;\n        this.normalTexture = Texture.WHITE;\n\n        if (layerAny.diffuseTexture && layerAny.normalTexture)\n        {\n            this.diffuseTexture = layerAny.diffuseTexture;\n            this.normalTexture = layerAny.normalTexture;\n        }\n        else\n        {\n            for (let j = 0; j < stage._activeLayers.length; j++)\n            {\n                const texLayer = stage._activeLayers[j];\n\n                if (texLayer.group === normalGroup)\n                {\n                    this.normalTexture = texLayer.getRenderTexture();\n                }\n                if (texLayer.group === diffuseGroup)\n                {\n                    this.diffuseTexture = texLayer.getRenderTexture();\n                }\n            }\n        }\n    }\n\n    static _instance = new LayerFinder();\n}\n","import { Rectangle, Quad } from '@pixi/core';\n\n/**\n * @extends PIXI.Quad\n * @memberof PIXI.lights\n */\nexport class ViewportQuad extends Quad\n{\n    /**\n     * Update\n     * @param {PIXI.Rectangle} viewport -\n     */\n    update(viewport: Rectangle): void\n    {\n        const b = this.buffers[0].data as Float32Array;\n\n        const x1 = viewport.x;\n        const y1 = viewport.y;\n        const x2 = viewport.x + viewport.width;\n        const y2 = viewport.y + viewport.height;\n\n        if (b[0] !== x1 || b[1] !== y1\n            || b[4] !== x2 || b[5] !== y2)\n        {\n            b[0] = b[6] = x1;\n            b[1] = b[3] = y1;\n            b[2] = b[4] = x2;\n            b[5] = b[7] = y2;\n            this.buffers[0].update();\n        }\n    }\n\n    static _instance: ViewportQuad = new ViewportQuad();\n}\n","import { Geometry, Renderer, BLEND_MODES, DRAW_MODES } from '@pixi/core';\nimport { Layer } from '@pixi/layers';\nimport { Mesh } from '@pixi/mesh';\nimport { LayerFinder, lightGroup } from '../../LayerFinder';\nimport { LightShader } from './LightShader';\nimport { ViewportQuad } from './ViewportQuad';\n\n/**\n * Base light class.\n * @extends PIXI.Mesh\n * @memberof PIXI.lights\n */\nexport class Light extends Mesh\n{\n    /** Light height */\n    lightHeight: number;\n    /** Brightness */\n    brightness: number;\n    /** Shader name */\n    shaderName: string | null = null;\n    /** Use Viewport Quad */\n    readonly useViewportQuad: boolean;\n\n    /**\n     * @param {number} [color=0xFFFFFF] - The color of the light.\n     * @param {number} [brightness=1] - The brightness of the light, in range [0, 1].\n     * @param {PIXI.lights.LightShader} [material] -\n     * @param {Float32Array} [vertices] -\n     * @param {Uint16Array} [indices] -\n     */\n    constructor(color = 0x4d4d59, brightness = 0.8, material: LightShader,\n        vertices? : Float32Array, indices?: Uint16Array)\n    {\n        super(!vertices ? ViewportQuad._instance : new Geometry()\n            .addAttribute('aVertexPosition', vertices).addIndex(indices), material);\n\n        this.blendMode = BLEND_MODES.ADD;\n        const useViewportQuad = !vertices;\n\n        this.drawMode = useViewportQuad ? DRAW_MODES.TRIANGLE_STRIP : DRAW_MODES.TRIANGLES;\n\n        /**\n         * The height of the light from the viewport.\n         *\n         * @default 0.075\n         */\n        this.lightHeight = 0.075;\n\n        /**\n         * The falloff attenuation coeficients.\n         *\n         * @member {number[]}\n         * @default [0.75, 3, 20]\n         */\n        this.falloff = [0.75, 3, 20];\n\n        /**\n         * By default the light uses a viewport sized quad as the mesh.\n         *\n         * @member {boolean}\n         */\n        this.useViewportQuad = useViewportQuad;\n\n        // color and brightness are exposed through setters\n        this.tint = color ?? 0x4d4d59;\n        this.brightness = brightness;\n        this.parentGroup = lightGroup;\n    }\n\n    /**\n     * The color of the lighting.\n     */\n    get color(): number\n    {\n        return this.tint;\n    }\n    set color(val: number)\n    {\n        this.tint = val;\n    }\n\n    /**\n     * Falloff\n     * @member {number[]}\n     */\n    get falloff(): ArrayLike<number>\n    {\n        return this.material.uniforms.uLightFalloff;\n    }\n\n    set falloff(value: ArrayLike<number>)\n    {\n        this.material.uniforms.uLightFalloff[0] = value[0];\n        this.material.uniforms.uLightFalloff[1] = value[1];\n        this.material.uniforms.uLightFalloff[2] = value[2];\n    }\n\n    /**\n     * Last layer\n     * @type {PIXI.layers.Layer}\n     */\n    lastLayer: Layer | null = null;\n\n    /**\n     * Sync Shader\n     * @param {PIXI.Renderer} renderer - Renderer\n     */\n    syncShader(renderer: Renderer): void\n    {\n        const { uniforms } = this.shader;\n\n        // TODO: actually pass UV's of screen instead of size\n        uniforms.uViewSize[0] = renderer.screen.width;\n        uniforms.uViewSize[1] = renderer.screen.height;\n        uniforms.uViewPixels[0] = renderer.view.width;\n        uniforms.uViewPixels[1] = renderer.view.height;\n        uniforms.uFlipY = !renderer.framebuffer.current;\n        uniforms.uSampler = LayerFinder._instance.diffuseTexture;\n        uniforms.uNormalSampler = LayerFinder._instance.normalTexture;\n        uniforms.uUseViewportQuad = this.useViewportQuad;\n        uniforms.uBrightness = this.brightness;\n    }\n\n    _renderDefault(renderer: Renderer): void\n    {\n        if (!this._activeParentLayer)\n        {\n            return;\n        }\n        LayerFinder._instance.check(this._activeParentLayer);\n\n        const shader = this.shader as unknown as LightShader;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n        if (this.useViewportQuad)\n        {\n            // TODO: pass the viewport (translated screen) instead\n            (this.geometry as ViewportQuad).update(renderer.screen);\n        }\n\n        this.syncShader(renderer);\n\n        renderer.shader.bind(shader);\n\n        renderer.state.set(this.state);\n\n        renderer.geometry.bind(this.geometry, shader);\n\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n}\n","/* eslint-disable @typescript-eslint/no-inferrable-types */\nexport const combine: string = `vec3 intensity = diffuse * attenuation;\nvec4 diffuseColor = texture2D(uSampler, texCoord);\nvec3 finalColor = diffuseColor.rgb * intensity;\n\ngl_FragColor = vec4(finalColor, diffuseColor.a);\n`;\n\nexport const commonUniforms: string = `uniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewPixels;   // size of the viewport, in pixels\nuniform vec2 uViewSize;     // size of the viewport, in CSS\n\nuniform vec4 uColor;   // light color, alpha channel used for intensity.\nuniform float uBrightness;\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\nuniform float uFlipY;             // whether we use renderTexture, FBO is flipped\n`;\n\nexport const computeDiffuse: string = `// normalize vectors\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\nvec3 L = normalize(lightVector);\n\n// pre-multiply light color with intensity\n// then perform \"N dot L\" to determine our diffuse\nvec3 diffuse = uColor.rgb * uBrightness * max(dot(N, L), 0.0);\n`;\n\nexport const computeVertexPosition: string = `vec2 texCoord = gl_FragCoord.xy / uViewPixels;\ntexCoord.y = (1.0 - texCoord.y) * uFlipY + texCoord.y * (1.0 - uFlipY); // FBOs positions are flipped.\n`;\n\nexport const loadNormals: string = `vec4 normalColor = texture2D(uNormalSampler, texCoord);\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\n\n// bail out early when normal has no data\nif (normalColor.a == 0.0) discard;\n`;\n\nexport const vert: string = `attribute vec2 aVertexPosition;\n\nuniform bool uUseViewportQuad;\nuniform mat3 translationMatrix;\nuniform mat3 projectionMatrix;\n\nvoid main(void) {\n    if (uUseViewportQuad) {\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n    else\n    {\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    }\n}\n`;\n","import { Texture, utils, Matrix } from '@pixi/core';\nimport { IMeshMaterialOptions, MeshMaterial } from '@pixi/mesh';\nimport { vert } from '../shared';\n\n/**\n * @extends PIXI.MeshMaterial\n * @memberof PIXI.lights\n */\nexport class LightShader extends MeshMaterial\n{\n    /**\n     * @param {PIXI.lights.IMeshMaterialOptions} [options] - Options to use.\n     */\n    constructor(options?: IMeshMaterialOptions)\n    {\n        const uniforms: utils.Dict<any> = {\n            translationMatrix: Matrix.IDENTITY.toArray(true),\n            // textures from the previously rendered FBOs\n            uNormalSampler: Texture.WHITE,\n            // size of the renderer viewport, CSS\n            uViewSize: new Float32Array(2),\n            // same, in PIXELS\n            uViewPixels: new Float32Array(2),\n            // light falloff attenuation coefficients\n            uLightFalloff: new Float32Array([0, 0, 0]),\n            // height of the light above the viewport\n            uLightHeight: 0.075,\n            uBrightness: 1.0,\n            uUseViewportQuad: true,\n        };\n\n        Object.assign(uniforms, options?.uniforms);\n\n        super(Texture.WHITE, { ...options, uniforms });\n    }\n\n    static defaultVertexSrc: string = vert;\n}\n","import { commonUniforms, computeVertexPosition, loadNormals } from '../shared';\n\nexport const ambientFrag = `precision highp float;\n\n${commonUniforms}\n\nvoid main(void)\n{\n${computeVertexPosition}\n${loadNormals}\n    // simplified lambert shading that makes assumptions for ambient color\n    vec3 diffuse = uColor.rgb * uBrightness;\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\n    vec3 finalColor = diffuseColor.rgb * diffuse;\n\n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n`;\n","import { Program } from '@pixi/core';\nimport { LightShader } from '../light/LightShader';\nimport { ambientFrag } from './ambient.frag';\n\n/**\n * @memberof PIXI.lights\n */\nexport class AmbientLightShader extends LightShader\n{\n    constructor()\n    {\n        super({\n            program: AmbientLightShader._program\n        });\n    }\n\n    static _program = new Program(LightShader.defaultVertexSrc, ambientFrag);\n}\n","import { Light } from '../light/Light';\nimport { AmbientLightShader } from './AmbientLightShader';\n\n/**\n * Ambient light is drawn using a full-screen quad.\n * @memberof PIXI.lights\n */\nexport class AmbientLight extends Light\n{\n    /**\n     * @param {number} [color=0xFFFFFF] - The color of the light.\n     * @param {number} [brightness=0.5] - The brightness of the light.\n     */\n    constructor(color = 0xFFFFFF, brightness = 0.5)\n    {\n        super(color, brightness, new AmbientLightShader());\n    }\n}\n","import { combine, commonUniforms, computeDiffuse, computeVertexPosition, loadNormals } from '../shared';\n\nexport const pointFrag = `precision highp float;\n\n// imports the common uniforms like samplers, and ambient color\n${commonUniforms}\n\nuniform float uLightRadius;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n${combine}\n}\n`;\n","import { Program } from '@pixi/core';\nimport { LightShader } from '../light/LightShader';\nimport { pointFrag } from './point.frag';\n\n/**\n * @memberof PIXI.lights\n */\nexport class PointLightShader extends LightShader\n{\n    constructor()\n    {\n        super({\n            program: PointLightShader._program,\n            uniforms: {\n                uLightRadius: 1.0\n            }\n        });\n    }\n\n    static _program = new Program(LightShader.defaultVertexSrc, pointFrag);\n}\n","import { Light } from '../light/Light';\nimport { Circle, DRAW_MODES } from '@pixi/core';\nimport { getCircleMesh } from '../../mixins/Circle';\nimport { PointLightShader } from './PointLightShader';\n\n/**\n * @memberof PIXI.lights\n */\nexport class PointLight extends Light\n{\n    /**\n     * @param {number} [color=0xFFFFFF] - The color of the light.\n     * @param {number} [brightness=1] - The intensity of the light.\n     * @param {number} [radius=Infinity] - The distance the light reaches. You will likely need\n     *  to change the falloff of the light as well if you change this value. Infinity will\n     *  use the entire viewport as the drawing surface.\n     */\n    constructor(color = 0xFFFFFF, brightness = 1, radius = Infinity)\n    {\n        if (radius !== Infinity)\n        {\n            const shape = new Circle(0, 0, radius);\n            const { vertices, indices } = getCircleMesh(shape);\n\n            super(color, brightness, new PointLightShader(), vertices, indices);\n\n            this.drawMode = DRAW_MODES.TRIANGLE_FAN;\n        }\n        else\n        {\n            super(color, brightness, new PointLightShader());\n        }\n        this.shaderName = 'pointLightShader';\n        this.radius = radius;\n    }\n\n    /** Radius */\n    get radius(): number\n    {\n        return this.material.uniforms.uLightRadius;\n    }\n\n    set radius(value: number)\n    {\n        this.material.uniforms.uLightRadius = value;\n    }\n}\n","import { combine, commonUniforms, computeDiffuse, computeVertexPosition, loadNormals } from '../shared';\n\nexport const directionalFrag = `precision highp float;\n\n// imports the common uniforms like samplers, and ambient/light color\n${commonUniforms}\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\n${computeVertexPosition}\n${loadNormals}\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n${computeDiffuse}\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n${combine}\n}\n`;\n","import { Program, Point } from '@pixi/core';\nimport { LightShader } from '../light/LightShader';\nimport { directionalFrag } from './directional.frag';\n\n/**\n * @memberof PIXI.lights\n */\nexport class DirectionalLightShader extends LightShader\n{\n    constructor()\n    {\n        super({\n            program: DirectionalLightShader._program,\n            uniforms: {\n                uLightRadius: 1.0,\n                uLightDirection: new Point()\n            }\n        });\n    }\n\n    static _program = new Program(LightShader.defaultVertexSrc, directionalFrag);\n}\n","import { Light } from '../light/Light';\nimport { Point, Renderer } from '@pixi/core';\nimport { DisplayObject } from '@pixi/display';\nimport { DirectionalLightShader } from './DirectionalLightShader';\n\n/**\n * Directional light is drawn using a full-screen quad.\n * @memberof PIXI.lights\n */\nexport class DirectionalLight extends Light\n{\n    target: DisplayObject | Point;\n\n    /**\n     * @param {number} [color=0xFFFFFF] - The color of the light.\n     * @param {number} [brightness=1] - The intensity of the light.\n     * @param {PIXI.DisplayObject|PIXI.Point} [target] - The object in the scene to target.\n     */\n    constructor(color = 0xFFFFFF, brightness = 1, target: DisplayObject | Point)\n    {\n        super(color, brightness, new DirectionalLightShader());\n\n        this.target = target;\n    }\n\n    /**\n     * Sync shader\n     * @param {PIXI.Renderer} renderer - Renderer\n     */\n    override syncShader(renderer: Renderer): void\n    {\n        super.syncShader(renderer);\n\n        const shader = this.material;\n\n        const vec = shader.uniforms.uLightDirection;\n        const wt = this.worldTransform;\n        const twt = (this.target as any).worldTransform;\n\n        let tx: number;\n        let ty: number;\n\n        if (twt)\n        {\n            tx = twt.tx;\n            ty = twt.ty;\n        }\n        else\n        {\n            tx = this.target.x;\n            ty = this.target.y;\n        }\n\n        // calculate direction from this light to the target\n        vec.x = wt.tx - tx;\n        vec.y = wt.ty - ty;\n\n        // normalize\n        const len = Math.sqrt((vec.x * vec.x) + (vec.y * vec.y));\n\n        vec.x /= len;\n        vec.y /= len;\n    }\n}\n"],"names":["getCircleMesh","shape","totalSegments","vertices","indices","seg","indicesIndex","i","index","angle","diffuseGroup","Group","normalGroup","lightGroup","_LayerFinder","layer","stage","layerAny","Texture","j","texLayer","LayerFinder","_ViewportQuad","Quad","viewport","b","x1","y1","x2","y2","ViewportQuad","Light","Mesh","color","brightness","material","Geometry","BLEND_MODES","useViewportQuad","DRAW_MODES","val","value","renderer","uniforms","shader","combine","commonUniforms","computeDiffuse","computeVertexPosition","loadNormals","vert","o","n","m","a","c","f","e","r","t","s","u","LightShader","MeshMaterial","options","Matrix","__spreadProps","__spreadValues","ambientFrag","_AmbientLightShader","AmbientLightShader","Program","AmbientLight","pointFrag","_PointLightShader","PointLightShader","PointLight","radius","Circle","directionalFrag","_DirectionalLightShader","Point","DirectionalLightShader","DirectionalLight","target","vec","wt","twt","tx","ty","len"],"mappings":"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"}